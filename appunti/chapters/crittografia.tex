\section{Elementi di teoria dei numeri}

\begin{definition}[Divisibilità]
    \label{def:divisibilita}
    Si dice che $d$ divide $a$, e $a$ è multiplo di $d$ se,
    $
    \forall d \ne 0 \in \mathbb{Z}
    ,
    a \in \mathbb{Z}
    $
    \begin{equation*}
        d | a 
        \quad
        \text{se}
        \quad
        \exists k \in \mathbb{Z} : a = kd
    \end{equation*}
\end{definition}
\begin{definition}[Divisore]
    \label{def:divisore}
    Se $d$ divide $a$ e $d>0$ si dice che è divisore di $a$.
    Per esempio $-2$ divide $8$, mentre $2$ è divisore di $8$.
\end{definition}
Valgono le seguenti proposizioni riguardo alla divisibilità:
\begin{proposizione}
    $\forall d \in \mathbb{Z} - \left\{ 0 \right\}
    \Rightarrow
    d | 0$
\end{proposizione}
\begin{proposizione}
    $
    \left( d | a \right)
    \wedge
    \left( a \ne 0 \right)
    \Rightarrow
    |d| \leq |a|
    $
\end{proposizione}
\begin{corollario}
    \label{cor:divisore_limite}
    $
    \left( d | a \right)
    \wedge
    \left( a,d > 0 \right)
    \Rightarrow
    d \leq a
    $
\end{corollario}
\begin{proposizione}
    $
    \left( b | a \right)
    \wedge
    \left( a | b \right)
    \Rightarrow
    a = \pm b
    $ ovvero $
    |a| = |b|
    $
\end{proposizione}
\begin{definition}[Numero primo]
    \label{def:numeroprimo}
    $p > 1$ è primo se ha come divisori solo $1$ e $p$. Il numero $1$ non è considerato primo.
\end{definition}
\begin{theorem}[Divisione]
    \label{teo:divisione}
    Il teorema di divisione garantisce l'esistenza e l'unicità di quoziente e resto.
    \begin{equation*}
        \forall a \in \mathbb{Z}, \forall n \in \mathbb{Z}^+
        \quad
        \exists !
        \;
        q, r :
        a = qn + r
    \end{equation*}
    Dove $q$ è detto il quoziente della divisione intera
    \begin{equation*}
        q \in \mathbb{Z}
        \quad
        q = \left\lfloor 
            \frac{a}{n}
        \right\rfloor
        = a \divv n
    \end{equation*}
    E $r$ è detto resto della divisione intera
    \begin{equation*}
        r \in \mathbb{N}, 0 \leq r < n
        \quad
        r = a \bmod n
    \end{equation*}
\end{theorem}
\begin{corollario}
    Il teorema di divisione prova formalmente quello che si è già visto molto spesso per cui 
    \begin{equation*}
        -1 \bmod n = n-1
        \quad
        -1 = \left( -1 \right) n + \left( n-1 \right)
    \end{equation*}
\end{corollario}
\begin{definition} [Divisori comuni]
    \label{def:divisoricomuni}
    Dati $d > 0, a, b \in \mathbb{Z}$; $d$ è divisore comune di $a$ e $b$ se 
    $d|a$
    e
    $d|b$.
\end{definition}
\begin{proposizione}
    \label{prop:divisore_cli}
    Se $d$ è divisore comune di $a$ e $b$, è anche divisore di ogni loro combinazione lineare intera:
    \begin{equation*}
        \left( 
            d|a
        \right)
        \wedge
        \left( 
            d|b
        \right)
        \Rightarrow
        \forall x, y \in \mathbb{Z} :
        d | ax + by
    \end{equation*}
    \begin{proof}
        $d | a \leftrightarrow \exists k_a : a = k_a d$ 
        e
        $d | b \leftrightarrow \exists k_b : b = k_b d$ 
        allora si riscrive 
        $
        ax + by = k_a d x + k_b d y
        =
        \left( k_a x + k_b y \right) d
        $ e posto $
        k_d = 
        \left( k_a x + k_b y \right)
        $ vale $
        ax + by = k_d d
        $.
    \end{proof}
\end{proposizione}
\begin{definition} [Massimo comun divisore]
    \label{def:gcd}
    Siano $a, b \in \mathbb{Z} : |a| + |b| > 0$
    Il massimo comun divisore (\emph{greatest common divisor} o GCD) di $a$ e $b$ è
    \begin{equation*}
        gcd(a, b) = \max \left\{ 
            d > 0 :
            \left( 
                d|a
            \right)
            \wedge
            \left( 
                d|b
            \right)
        \right\}
    \end{equation*}
    L'ipotesi $|a| + |b| > 0$ garantisce che l'insieme sia limitato.
    Si pone per convenzione
    \begin{equation*}
        gcd(0,0) = 0
    \end{equation*}
\end{definition}
Valgono le seguenti proposizioni riguardo al GCD:
\begin{proposizione}
    \label{prop:gcd_bound}
    $ 
    |a| + |b| > 0
    \Rightarrow 
    1 \leq gcd(a,b)
    \leq \min \left\{ |a|, |b| \right\}
    $
\end{proposizione}
\begin{proposizione}
    \label{prop:gcd_zero}
    $ 
    \forall a \in \mathbb{Z}
    \Rightarrow 
    gcd(a,0) = |a|
    $ (anche per $a=0$ è coerente)
\end{proposizione}
\begin{proposizione}[Sign insensitivity]
    Vale
    \begin{equation*}
        gcd(a,b) =
        gcd(-a,b) =
        gcd(a,-b) =
        gcd(-a,-b) =
        gcd(|a|,|b|)
    \end{equation*}
    Questo permette di limitarsi allo studio dei naturali senza perdita di generalità.
\end{proposizione}
\begin{theorem} [Identità di Bézout]
    \label{teo:bezout}
    Sotto l'ipotesi $|a| + |b| > 0$, il GCD
    di $a$ e $b$
    è la minima combinazione lineare intera positiva 
    di $a$ e $b$.
    \begin{equation*}
        gcd(a,b) =
        \min \left\{ 
            d > 0 :
            \exists x, y \in \mathbb{Z} :
            d = ax + by
        \right\}
    \end{equation*}
    \begin{proof}
        Si mostra l'uguaglianza $
        gcd(a,b) = s
        $ dimostrando la minorazione e maggiorazione.
        \\
        ``$ gcd(a,b) \leq s $'':
        Per definizione di GCD vale $
        \left( 
            gcd(a,b) | a
        \right)
        \wedge
        \left( 
            gcd(a,b) | b
        \right)
        $
        e per la proprietà \ref{prop:divisore_cli} vale $
        gcd(a,b) 
        | ax + by
        ,
        \forall x, y \in \mathbb{Z}
        $.
        Se divide tutte le combinazioni lineari intere, deve dividere anche $s$:
        $
        gcd(a,b) | s
        $.
        Valgono le ipotesi della proposizione \ref{prop:gcd_bound} ($|a| + |b| > 0$), quindi $
        gcd(a,b) > 0
        $.
        Anche $s>0$ perché è il minimo di un insieme di numeri positivi.
        Entrambe le quantità sono positive e la prima divide la seconda, per cui dalla divisibilità discende $
        gcd(a,b) \leq s
        $ (corollario \ref{cor:divisore_limite}).
        \\
        ``$ gcd(a,b) \geq s $'':
        Prima di mostrare la minorazione, occorre dimostrare che
        \begin{equation*}
            \forall x, y \in \mathbb{Z}
            ,
            \;\;
            s | ax + by
        \end{equation*}
        Sia $
        s = a \bar{x} + b \bar{y}
        $ la combinazione minima e $
        c = ax + by
        $ una combinazione generica, si applica il teorema di divisione tra $c$ e $s$:
        \begin{equation*}
            \exists ! q, r :
            c = qs + r
            ,
            \quad
            0 \leq r < s
        \end{equation*}
        va mostrato che deve valere $r=0$, e quindi $s$ divide $c$.
        Si riscrive
        \begin{align*}
            r &= 
            c - qs
            \\
            &= 
            ax + by - q\left( 
                a \bar{x} + b \bar{y}
            \right)
            \\
            &= 
            a \left( 
                x - q \bar{x}
            \right)
            +
            b \left( 
                y - q \bar{y}
            \right)
            \\
            &=
            ax' + by'
        \end{align*}
        E si è mostrato che $r$ è combinazione lineare intera di $a$ e $b$.
        Ma $s$ era il minimo delle combinazioni lineari intere positive, quindi $r$ (che può assumere valori $
            0 \leq r < s
        $) non può essere positivo, perché avrebbe valore inferiore a $s$, e deve essere $r=0$.
        \\
        Avendo mostrato che $s$ divide ogni combinazione lineare intera, se ne possono scegliere due particolari:
        \begin{equation*}
            s | a \cdot 1 + b \cdot 0 = a
            \quad
            \text{e}
            \quad
            s | a \cdot 0 + b \cdot 1 = b
        \end{equation*}
        Ossia $s$ è divisore comune, minore o uguale al \emph{massimo} comun divisore: $
        gcd(a,b) \geq s 
        $.
    \end{proof}
\end{theorem}

\subsection{Teorema di Euclide}

Per il calcolo efficace del GCD si utilizza l'algoritmo di Euclide, considerato il primo esempio di algoritmo efficiente della storia.

\begin{theorem} [Euclide]
    \label{teo:euclide}
    Siano $a,b \geq 0$ (il GCD è invariante per segno, non si perde di generalità), allora
    \begin{align*}
        b=0
        &
        \Rightarrow
        gcd(a,b) =
        gcd(a,0) = a
        \\
        b>0
        &
        \Rightarrow
        gcd(a,b) =
        gcd(b,
            a \bmod b
        )
    \end{align*}
    \begin{proof}
        La prima implicazione è corrispondente alla proposizione \ref{prop:gcd_zero}.
        \\
        La seconda si prova in due parti:
        \\
        ``$ gcd(a,b) \leq gcd(b, a \bmod b) $'':
        Si applica il teorema di divisione ad $a$ e $b$:
        \begin{equation*}
            a = qb + r = qb + a \bmod b
            \quad
            \rightarrow
            \quad
            a \bmod b = a - qb
        \end{equation*}
        E si riscrive quindi
        \begin{align*}
            gcd(b, a \bmod b)
            &= 
            gcd(b, a - qb)
            % \intertext{a cui si applica il teorema di Bézout:
            % $ \exists x', y' \in \mathbb{Z} : $
            % }
            \\
            \text{per Bézout:
            $ \exists x', y' \in \mathbb{Z} : $
            }
            \quad
            &
            =
            b x' + 
            \left( 
                a - qb
            \right) y'
            \\
            &= 
            a y'
            +
            b
            \left( 
                x' - qy'
            \right)
        \end{align*}
        Per cui il $
        gcd(b, a \bmod b)
        $ è combinazione lineare intera positiva di $a$ e $b$ e sempre per Bézout, deve essere maggiore o uguale del $
        gcd(a, b)
        $, che è la minima combinazione lineare intera positiva:
        $ gcd(a,b) \leq gcd(b, a \bmod b) $.
        \\
        ``$ gcd(a,b) \geq gcd(b, a \bmod b) $'':
        Sia $
        d' = gcd(b, a \bmod b)
        $, allora valgono
        \begin{align*}
            d' | b 
            \Rightarrow
            \exists k' 
            &
            : b = k' d'
            \\
            d' | a \bmod b
            \Rightarrow
            \exists k'' 
            &
            : a \bmod b = k'' d'
        \end{align*}
        E si riscrive dal teorema di divisione
        \begin{align*}
            a
            &= 
            qb + a \bmod b
            \\
            &= 
            q k' d' 
            +
            k'' d'
            \\
            &= 
            \left( 
                q k' + k''
            \right) d'
        \end{align*}
        Quindi $
        \left( d' | a \right)
        $ e chiaramente $
        \left( d' | b \right)
        $, per cui $d'$ è divisore comune di $a$ e $b$, e deve essere minore del \emph{massimo} comun divisore.
    \end{proof}
\end{theorem}
Questo teorema mostra una chiara proprietà di sottostruttura, che riscrive la soluzione in funzione di istanze più piccole del problema.
\begin{algorithm}[H]
\caption{Algoritmo di Euclide}\label{alg:euclide}
\begin{algorithmic}[1]
    \Procedure{Euclid}{$a, b$}
        \If{$b = 0$}
            \State return $a$
        \EndIf
        \State return \Call{Euclid}{$b, a \bmod b$}
    \EndProcedure
\end{algorithmic}
\end{algorithm}
Se $a < b$ la prima iterazione scambia i valori ($
    a \bmod b = a
$), e alle successive iterazioni vale $b < a$ e quindi $a \bmod b < b$, essendo un minore stretto l'algortimo termina.
La correttezza dell'algoritmo è assicurata dal teorema precedente.

Per l'analisi della complessità, vanno introdotti i numeri di Fibonacci.
\begin{definition}
    [Numeri di Fibonacci]
    \label{def:numerifibonacci}
    I numeri di Fibonacci sono definiti come
    \begin{align*}
        F_1 &= 1
        \\
        F_2 &= 2
        \\
        F_{k+1}
        &=  
        F_{k} +
        F_{k-1}
        \quad
        \text{per}
        \quad
        k \geq 2
    \end{align*}
    Il cui valore è calcolabile in formula chiusa:
    \begin{align*}
        F_k &= 
        \frac{1}{
            \sqrt{5}
        }
        \left( 
            \frac{1 + 
                \sqrt{5}
            }{2}
        \right)^{k}
        -
        \frac{1}{
            \sqrt{5}
        }
        \left( 
            \frac{1 -
                \sqrt{5}
            }{2}
        \right)^{k}
        \\
        &
        \geq
        \frac{1}{
            \sqrt{5}
        }
        \left( 
            \frac{1 + 
                \sqrt{5}
            }{2}
        \right)^{k}
    \end{align*}
    I numeri di Fibonacci crescono come un esponenziale.
\end{definition}
Supponendo di conoscere il numero di chiamate $k$ eseguite dall'algoritmo di Euclide, allora si dimostra che i parametri iniziali erano grandi rispetto al numero di chiamate.
\begin{lemma}
    \label{lem:euclide_iterazioni}
    Se $
    a > b > 0
    $, allora $
    a 
    $
\end{lemma}

\section{Pezzi utili di \LaTeX{}}
\begin{algorithm}[H]
\caption{Divide and Conquer}\label{alg:dnc}
\begin{algorithmic}[1]
    \Procedure{Divide\&Conquer}{$i$}
        \If{$|i| \leq n_0$}
        \Comment{BASE}
            \State *risolvo direttamente*
        \EndIf
        \State $\langle i_1, i_2, \dots, i_k \rangle \gets A_D(i)$ 
        \Comment{DIVIDE}
        \For{$j \gets 1 $ to $ k $ }
        \Comment{RECURSE}
            \State $s_j \gets $ \Call{Divide\&Conquer}{$i_j$}
        \EndFor
        \State $s \gets A_C(\langle s_1, s_2, \dots, s_k \rangle)$
        \Comment{CONQUER}
        \State return $s$
    \EndProcedure
\end{algorithmic}
\end{algorithm}
\noindent
Testo non identato!

\begin{definition}[Algoritmo]\label{def:algex}
    Un algoritmo è una procedura computazionale finita (terminante) e deterministica, specificata come una sequenza di passi elementari (istruzioni) estratte da un insieme standard associato a un modello computazionale (astrazione di un computer) che trasforma in maniera univoca un ingresso in un uscita.
\end{definition}

Guarda che so fare
\begin{equation*}
    \setzo{m}
    \quad
    \setzo{}
\end{equation*}

Un problema
\begin{align*}
    SS: & \\
    \texttt{istanza:} \quad & \langle S,t \rangle \\
    \text{dove} \quad & S \subseteq \mathbb{N} - \left\{ 0 \right\} \text{ finito} \\
    & t \subseteq \mathbb{N} - \left\{ 0 \right\} \\
    \texttt{domanda:} \quad & \exists \, S' \subseteq S : \sum_{s \in S'}^{} s = t \, ?
\end{align*}

Una lista
\begin{itemize}[noitemsep,parsep=0pt,partopsep=0pt,topsep=0pt]
    \item[--] $L_A = L$ (il linguaggio deciso da $A$ è $L$)
    \item[--] $T_A(|x|) = O(|x|^k)$ per qualche costante $k \geq 0$
\end{itemize}

Teoremi e varie

\begin{theorem}
    Un teorema senza nome
\end{theorem}

\begin{corollario}
    Un primo corollario
\end{corollario}

\begin{corollario}
    Un secondo corollario
\end{corollario}

\begin{theorem}[Nome del teorema]
    Un teorema con nome
\end{theorem}

\begin{corollario}
    Un primo corollario del teorema con nome
\end{corollario}

\begin{definition}
    Una definizione utile, la seconda di questa sezione
\end{definition}

\begin{proposizione}[Nome della proposizione]
    Una proposizione con nome
\end{proposizione}

\begin{corollario}
    Un primo corollario della proposizione con nome
\end{corollario}

\subsection{Grafi}

Grafi facili da mantenere

% Declare layers (done in main)
\pgfdeclarelayer{background}
\pgfsetlayers{background,main}

\begin{figure}[h]
    \centering
    \caption{Algoritmo di Prim}
    \label{fig:prim1}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \caption{Archi uscenti dal primo nodo}
        \label{fig:au1}
        \begin{tikzpicture} [
                % automagically put labels not on edges
                auto,
                % exchanges the roles of left and right in automatic placement
                % the side the label is put on depends on the order of the nodes in the edge
                swap,
                scale=1.4,
                vertex/.style={circle,fill=black!25,minimum size=20pt,inner sep=0pt},
                selected vertex/.style = {vertex, fill=red!24},
                edge/.style = {draw,thick,-},
                weight/.style = {font=\small},
                selected edge/.style = {draw,line width=5pt,-,red!50},
                outbound edge/.style = {draw,line width=5pt,-,blue!50},
                ignored edge/.style = {draw,line width=5pt,-,black!20}
            ]
            % First we draw the vertices
            \foreach \pos/\name in {
                {(0,0)/d}, {(0,2)/a}, {(1.5,2)/b}, {(4,2)/c}, {(3,1.2)/e}, {(2,0)/f}, {(4,0)/g}}
                \node[vertex] (\name) at \pos {$\name$};
            % Connect vertices with edges and draw weights
            \foreach \source/ \dest /\weight in {b/a/7, c/b/8, d/a/5, d/b/9,
                                                 e/b/7, e/c/5, e/d/15,
                                                 f/d/6, f/e/8, g/e/9, g/f/11}
                \path[edge] (\source) -- node[weight] {$\weight$} (\dest);
            % color a node
            % \path node[selected vertex] at (d) {$d$};
            % prepare it in loop version anyway
            \foreach \vertex in {d}
                \path node[selected vertex] at (\vertex) {$\vertex$};
            % For convenience we use a background layer to highlight edges
            % This way we don't have to worry about the highlighting covering
            % weight labels. 
            \begin{pgfonlayer}{background}
                \foreach \source / \dest in {d/a,d/b,d/e,d/f}
                    \path[outbound edge] (\source.center) -- (\dest.center);
            \end{pgfonlayer}
        \end{tikzpicture}
    \end{subfigure}
    \quad
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \caption{Arco selezionato}
        \label{fig:au2}
        \begin{tikzpicture} [
                auto,
                swap,
                scale=1.4,
                vertex/.style={circle,fill=black!25,minimum size=20pt,inner sep=0pt},
                selected vertex/.style = {vertex, fill=red!24},
                edge/.style = {draw,thick,-},
                weight/.style = {font=\small},
                selected edge/.style = {draw,line width=5pt,-,red!50},
                outbound edge/.style = {draw,line width=5pt,-,blue!50},
                ignored edge/.style = {draw,line width=5pt,-,black!20}
            ]
            % First we draw the vertices
            \foreach \pos/\name in {
                {(0,0)/d}, {(0,2)/a}, {(1.5,2)/b}, {(4,2)/c}, {(3,1.2)/e}, {(2,0)/f}, {(4,0)/g}}
                \node[vertex] (\name) at \pos {$\name$};
            % Connect vertices with edges and draw weights
            \foreach \source/ \dest /\weight in {b/a/7, c/b/8, d/a/5, d/b/9,
                                                 e/b/7, e/c/5, e/d/15,
                                                 f/d/6, f/e/8, g/e/9, g/f/11}
                \path[edge] (\source) -- node[weight] {$\weight$} (\dest);
            % color a node
            \foreach \vertex in {d,a}
                \path node[selected vertex] at (\vertex) {$\vertex$};
            \begin{pgfonlayer}{background}
                \foreach \source / \dest in {b/a,d/b,d/e,d/f}
                    \path[outbound edge] (\source.center) -- (\dest.center);
                \foreach \source / \dest in {d/a}
                    \path[selected edge] (\source.center) -- (\dest.center);
            \end{pgfonlayer}
        \end{tikzpicture}
    \end{subfigure}
    \\[2pt]
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \caption{Secondo arco selezionato}
        \label{fig:au3}
        \begin{tikzpicture} [
                auto,
                swap,
                scale=1.4,
                vertex/.style={circle,fill=black!25,minimum size=20pt,inner sep=0pt},
                selected vertex/.style = {vertex, fill=red!24},
                edge/.style = {draw,thick,-},
                weight/.style = {font=\small},
                selected edge/.style = {draw,line width=5pt,-,red!50},
                outbound edge/.style = {draw,line width=5pt,-,blue!50},
                ignored edge/.style = {draw,line width=5pt,-,black!20}
            ]
            % First we draw the vertices
            \foreach \pos/\name in {
                {(0,0)/d}, {(0,2)/a}, {(1.5,2)/b}, {(4,2)/c}, {(3,1.2)/e}, {(2,0)/f}, {(4,0)/g}}
                \node[vertex] (\name) at \pos {$\name$};
            % Connect vertices with edges and draw weights
            \foreach \source/ \dest /\weight in {b/a/7, c/b/8, d/a/5, d/b/9,
                                                 e/b/7, e/c/5, e/d/15,
                                                 f/d/6, f/e/8, g/e/9, g/f/11}
                \path[edge] (\source) -- node[weight] {$\weight$} (\dest);
            % color a node
            \foreach \vertex in {d,a}
                \path node[selected vertex] at (\vertex) {$\vertex$};
            \begin{pgfonlayer}{background}
                \foreach \source / \dest in {b/a,d/b,d/e,e/f,f/g}
                    \path[outbound edge] (\source.center) -- (\dest.center);
                \foreach \source / \dest in {d/a, d/f}
                    \path[selected edge] (\source.center) -- (\dest.center);
            \end{pgfonlayer}
        \end{tikzpicture}
    \end{subfigure}
    \quad
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \caption{Terzo arco selezionato, notare il primo arco ignorato, interno al $MST$.
            La subcaption può essere lunga assai, e brutte cose non succedono
        }
        \label{fig:au4}
        \begin{tikzpicture} [
                auto,
                swap,
                scale=1.4,
                vertex/.style={circle,fill=black!25,minimum size=20pt,inner sep=0pt},
                selected vertex/.style = {vertex, fill=red!24},
                edge/.style = {draw,thick,-},
                weight/.style = {font=\small},
                selected edge/.style = {draw,line width=5pt,-,red!50},
                outbound edge/.style = {draw,line width=5pt,-,blue!50},
                ignored edge/.style = {draw,line width=5pt,-,black!20}
            ]
            % First we draw the vertices
            \foreach \pos/\name in {
                {(0,0)/d}, {(0,2)/a}, {(1.5,2)/b}, {(4,2)/c}, {(3,1.2)/e}, {(2,0)/f}, {(4,0)/g}}
                \node[vertex] (\name) at \pos {$\name$};
            % Connect vertices with edges and draw weights
            \foreach \source/ \dest /\weight in {b/a/7, c/b/8, d/a/5, d/b/9,
                                                 e/b/7, e/c/5, e/d/15,
                                                 f/d/6, f/e/8, g/e/9, g/f/11}
                \path[edge] (\source) -- node[weight] {$\weight$} (\dest);
            % color a node
            \foreach \vertex in {d,a}
                \path node[selected vertex] at (\vertex) {$\vertex$};
            \begin{pgfonlayer}{background}
                \foreach \source / \dest in {d/b,d/e,e/f,f/g,b/e,b/c}
                    \path[outbound edge] (\source.center) -- (\dest.center);
                \foreach \source / \dest in {d/a, d/f, a/b}
                    \path[selected edge] (\source.center) -- (\dest.center);
                \foreach \source / \dest in {d/b}
                    \path[ignored edge] (\source.center) -- (\dest.center);
            \end{pgfonlayer}
        \end{tikzpicture}
    \end{subfigure}
\end{figure}

\begin{figure}[h]
    \centering
    \caption{Unweighted graph}
    \label{fig:ug}
    \begin{tikzpicture} [
            auto,
            swap,
            scale=1.4,
            vertex/.style={circle,fill=black!25,minimum size=20pt,inner sep=0pt},
            selected vertex/.style = {vertex, fill=red!24},
            edge/.style = {draw,thick,-},
            weight/.style = {font=\small},
            selected edge/.style = {draw,line width=5pt,-,red!50},
            outbound edge/.style = {draw,line width=5pt,-,blue!50},
            ignored edge/.style = {draw,line width=5pt,-,black!20}
        ]
        % First we draw the vertices
        \foreach \pos/\name in {
                {(0,0)/A},
                {(0,2)/B},
                {(2,2)/C},
                {(4,2)/D},
                {(2,0)/E},
                {(4,0)/F},
                {(6,2)/G}}
            \node[vertex] (\name) at \pos {$\name$};
        % Connect vertices with edges and draw weights
        \foreach \source/ \dest in {
                A/B, B/C, C/E, C/D, E/F, D/E, D/G, F/D}
            \path[edge] (\source) -- (\dest);
        % color a node
        \foreach \vertex in {B, D, E}
            \path node[selected vertex] at (\vertex) {$\vertex$};
        \begin{pgfonlayer}{background}
            \foreach \source / \dest in {B/C}
                \path[outbound edge] (\source.center) -- (\dest.center);
            \foreach \source / \dest in {D/G}
                \path[selected edge] (\source.center) -- (\dest.center);
            \foreach \source / \dest in {F/D}
                \path[ignored edge] (\source.center) -- (\dest.center);
        \end{pgfonlayer}
    \end{tikzpicture}
\end{figure}

\begin{figure}[h]
    \centering
    \caption{$FPW$}
    \label{fig:exbend}
    \begin{tikzpicture} [
            scale=1.4,
            vertex/.style={circle,fill=black!25,minimum size=20pt,inner sep=0pt},
            edge/.style = {draw,thick,-},
            outbound edge/.style = {draw,line width=8pt,-,blue!30},
            selected edge/.style = {draw,line width=8pt,-,red!30},
            arrow edge/.style = {draw,thick,->},
            bent right/.style = {bend right=20},
            bent left/.style = {bend left=20},
        ]
        \foreach \pos/\name in {
        {(0,0)/c}, {(2,0)/d}, {(1,1.5)/b}, {(3,1.5)/e}, {(2,3)/a}}
            \node[vertex] (\name) at \pos {$\name$};
        \foreach \source/ \dest in {
                b/c,b/d,a/b,a/e}
            \path[arrow edge] (\source) edge [bent right] (\dest);
        \foreach \source/ \dest in {
                c/b,d/b,b/a,e/a}
            \path[arrow edge] (\source) edge [bent right] (\dest);
        \begin{pgfonlayer}{background}
            \foreach \source / \dest in {a/b}
                \path[outbound edge] (\source) edge [bent right] (\dest);
            \foreach \source / \dest in {b/a}
                \path[selected edge] (\source) edge [bent right] (\dest);
        \end{pgfonlayer}
    \end{tikzpicture}
\end{figure}

% \lipsum{10}

\begin{figure}[!b]
% \begin{figure}[H]
    \centering
    \caption{Algoritmo di Christofides splittato in due pagine}
    \label{fig:mchristofides}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \caption{$T^*$ con i nodi dispari evidenziati}
        \label{fig:mchristmst}
        \begin{tikzpicture} [
                scale=1,
                vertex/.style={circle,fill=black!25,minimum size=20pt,inner sep=0pt},
                edge/.style = {draw,thick,-},
                selected vertex/.style = {vertex, fill=blue!24},
            ]
            \foreach \pos/\name in {
                    {(0,0)/c}, {(2,0)/d}, {(1,1.5)/b}, {(3,1.5)/e}, {(2,3)/a}}
                \node[vertex] (\name) at \pos {$\name$};
            \foreach \source/ \dest in {
                    b/c,b/d,a/b,a/e}
                \path[edge] (\source) edge (\dest);
            \foreach \vertex in {b,c,d,e}
                \path node[selected vertex] at (\vertex) {$\vertex$};
        \end{tikzpicture}
    \end{subfigure}
    \quad
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \caption{Sottografo (completo) indotto dai nodi dispari, e matching perfetto di costo minimo evidenziato}
        \label{fig:mchristmatching}
        \begin{tikzpicture} [
                scale=1,
                vertex/.style={circle,fill=black!25,minimum size=20pt,inner sep=0pt},
                edge/.style = {draw,thick,-},
                selected edge/.style = {draw,line width=5pt,-,blue!24},
            ]
            \foreach \pos/\name in {
                    {(0,0)/c}, {(2,0)/d}, {(1,1.5)/b}, {(3,1.5)/e}}
                \node[vertex] (\name) at \pos {$\name$};
            \foreach \source/ \dest in {
                    b/c,b/d,b/e,c/e,c/d,e/d}
                \path[edge] (\source) edge (\dest);
            \begin{pgfonlayer}{background}
                \foreach \source / \dest in {b/c,d/e}
                    \path[selected edge] (\source.center) -- (\dest.center);
            \end{pgfonlayer}
        \end{tikzpicture}
    \end{subfigure}
\end{figure}
    % \\[2pt]
% magic to split a figure https://tex.stackexchange.com/a/278748
\begin{figure}[htb]\ContinuedFloat
    \caption{Algoritmo di Christofides splittato in due pagine (cont.)}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \caption{Ciclo Euleriano
            $ \langle c,b,d,e,a,b,c \rangle$
        }
        \label{fig:mchristeulertour}
        \begin{tikzpicture} [
                scale=1,
                vertex/.style={circle,fill=black!25,minimum size=20pt,inner sep=0pt},
                edge/.style = {draw,thick,-},
                bent right/.style = {bend right=20},
            ]
            \foreach \pos/\name in {
                    {(0,0)/c}, {(2,0)/d}, {(1,1.5)/b}, {(3,1.5)/e}, {(2,3)/a}}
                \node[vertex] (\name) at \pos {$\name$};
            \foreach \source/ \dest in {
                    b/d,a/b,a/e,d/e}
                \path[edge] (\source) edge (\dest);
            \foreach \source/ \dest in {
                    c/b,b/c}
                \path[edge] (\source) edge [bent right] (\dest);
        \end{tikzpicture}
    \end{subfigure}
    \quad
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \caption{Dopo lo \emph{shortcutting}:
            $ \langle c,b,d,e,a,\cancel{b},c \rangle$
        }
        \label{fig:mchristresult}
        \begin{tikzpicture} [
                scale=1,
                vertex/.style={circle,fill=black!25,minimum size=20pt,inner sep=0pt},
                edge/.style = {draw,thick,-},
                bent right/.style = {bend right=30},
            ]
            \foreach \pos/\name in {
                    {(0,0)/c}, {(2,0)/d}, {(1,1.5)/b}, {(3,1.5)/e}, {(2,3)/a}}
                \node[vertex] (\name) at \pos {$\name$};
            \foreach \source/ \dest in {
                    b/d,a/e,d/e,b/c}
                \path[edge] (\source) edge (\dest);
            \foreach \source/ \dest in {
                    a/c}
                \path[edge] (\source) edge [bent right] (\dest);
        \end{tikzpicture}
    \end{subfigure}
\end{figure}

\lipsum{10}

\begin{figure}[h]
    \centering
    \caption{$3-CNF-SAT$ to $CLIQUE$}
    \label{fig:3cnfsatex}
    \begin{tikzpicture} [
            scale=1,
            vertex/.style={circle,fill=black!25,minimum size=20pt,inner sep=0pt},
            edge/.style = {draw,thin,-},
            outbound edge/.style = {draw,line width=4pt,-,blue!30},
            selected edge/.style = {draw,line width=4pt,-,red!30},
        ]
        % First we draw the vertices
        \foreach \pos/\name/\label in {
                % top left
                {(-1.5,5)/c/x_3},
                {(-2.5,3.5)/b/x_2},
                {(-3.5,2)/a/\bar{x_1}},
                % top right
                {(1.5,5)/d/x_1},
                {(2.5,3.5)/e/x_2},
                {(3.5,2)/f/\bar{x_3}},
                % bottom row
                {(2,0)/g/\bar{x_3}},
                {(0,0)/h/\bar{x_2}},
                {(-2,0)/i/x_1}}
            \node[vertex] (\name) at \pos {\name $\label$};
        % Connect vertices with edges
        \foreach \source/ \dest in {
                f/g,f/i,
                e/g,e/i,
                d/g,d/h,d/i,
                c/d,c/e,c/h,c/i,
                b/d,b/e,b/f,b/g,b/i,
                a/e,a/f,a/g,a/h}
            \path[edge] (\source) -- (\dest);
        % color some edges on background layer
        \begin{pgfonlayer}{background}
            \foreach \source / \dest in {c/d,d/i,i/c}
                \path[outbound edge] (\source.center) -- (\dest.center);
            \foreach \source / \dest in {a/e,e/g,g/a}
                \path[selected edge] (\source.center) -- (\dest.center);
        \end{pgfonlayer}
    \end{tikzpicture}
\end{figure}
